¿Para qué sirve una metodología?
--------------------------------

Una metodología nos ordena, nos contiene, nos permite definir límites. Construir software complejo requiere un gran esfuerzo: tecnología, dinero y sobre todo: personas. Personas que interactúan entre sí, con diferentes grados de conocimiento, con diferentes roles, con diferentes intereses. Una metodología propone un esquema de trabajo que nos permite entender cuál es nuestro rol dentro del proyecto, nos acerca una cierta sensación de tranquilidad, de seguridad. Sin un proceso no sabemos cómo comenzar y cuándo terminar.

Metodologías secuenciales / iterativas
--------------------------------------

En las metodologías secuenciales, el proceso de desarrollo de software se divide en varios pasos o fases. Cada fase tiene un conjunto de metas a cumplir. El fin de cada fase delimita el comienzo de la fase siguiente. Aunque son normales la superposición de fases, estas metodologías proponen una gran fase de análisis de requerimientos, otra de diseño, otra de construcción y otra de pruebas donde el alcance de cada fase es la totalidad de los requerimientos de un proyecto.

En las metodologías iterativas se divide el proyecto en entregas o iteraciones. Si cada iteración define un conjunto de metas a cumplir, podríamos pensar que no hay una gran diferencia con la metodología secuencial. No obstante, cada iteración define como entregable un software testeable por el usuario. Entonces hay etapas de análisis de requerimientos, diseño, construcción y prueba en cada iteración. Además, cada iteración permite revisar y cambiar los requerimientos a resolverse.

Metodologías orientadas al proceso / a las personas
---------------------------------------------------

Metodologías orientadas a la documentación / al producto
--------------------------------------------------------

Metodologías predictivas / adaptativas
--------------------------------------

Ejemplos concretos
------------------

-   **Modelo de Cascada**: originado en el [paper de Winston Royce: "Managing the development of large software systems"](http://www.cs.umd.edu/class/spring2003/cmsc838p/Process/waterfall.pdf) ordena por fases el desarrollo de software. Si bien las fases pueden llegar a solaparse, el proceso está concebido como secuencial ("el diseño debe ocurrir antes que el desarrollo: STEP 1 - PROGRAM DESIGN COMES FIRST"), orientado al proceso ("Begin the design process with program designers, not analysts or programmers"), orientado a la documentación ("how much documentation? My own view is 'quite a lot'; certainly more than most programmers, analysts, or program designers are willing to do if left to their own devices", "If the documentation is in serious default my first recommendation is simple: replace project management. \[...\] Stop all activities not related to documentation") y definitivamente predictivo.
-   **Espiral de Boehm**: originado en el [paper de Barry Boehm: "A Spiral Model of Software Development and Enhancement"](http://www.cs.umd.edu/class/spring2003/cmsc838p/Process/spiral.pdf), surge como primer contracara del modelo de cascada. Sigue un modelo de planificación de objetivos, identificación de riesgos y desarrollo y verificación del producto en n iteraciones, lo que lo convierte en adaptativo (contempla cambios más allá del análisis previo). Las primeras iteraciones pueden consistir en prototipos. No dice nada de Orientado a proceso / orientado a doc.
-   **Proceso unificado**:
-   **Metodologías ágiles**: algunas implementaciones conocidas son Scrum, XP, ASD.

Links relacionados
------------------

-   [Volver a Diseño de Sistemas](design-temario.html)

